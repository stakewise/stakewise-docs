---
title: Oracle Duties
sidebar_position: 1
description: "Learn about validator registration approval, reward distribution, and validator exits"
---

import Admonition from '@theme/Admonition';

```mdx-code-block
import Tooltip from '@site/src/components/Tooltip/Tooltip';
```

# Oracle Duties

Oracles run the [v3-oracle ↗](https://github.com/stakewise/v3-oracle) nodes and are responsible for validator registration, reward distribution, and validator exits.

## Validator Registration Approval

Oracles approve validator registration requests before they are submitted to the Beacon Chain [Deposit Contract ↗](https://etherscan.io/address/0x00000000219ab540356cbb839cbe05303d7705fa#code).

The [Operator Service →](../../operator/start-operator) periodically checks whether its Vaults have accumulated enough ETH for registering new validator(s).
When the Vault has enough ETH, the operator sends a registration approval request to Oracles that includes encrypted exit signature(s) for the validator(s) it is attempting to create.
This is done to maintain the protocol's ability to exit validators on demand, and to perform checks against the front-running withdrawal credentials attack described [here ↗](https://blog.lido.fi/vulnerability-response-update/).
The operator must receive **8 out of 11 approvals** from Oracles to register a validator for the Vault.

:::custom-notes[Approval Process]
1. Operator sends the validator registration requests and encrypted exit signatures to the Oracles.
2. Oracles sign approval messages that include the current tree root hash from the Beacon Chain Deposit Contract.
3. Operator submits registration to the Vault contract with Oracle signatures.
4. Vault contract calls the [Keeper contract ↗](https://etherscan.io/address/0x6B5815467da09DaA7DC83Db21c9239d98Bb487b5#code) to validate Oracle signatures and confirm the tree root hash hasn't changed.
5. Vault transfers ETH to the Beacon Chain deposit contract to complete validator registration.
:::

This process ensures Oracles approve validators based on current Beacon Chain state, bridging the consensus and execution layers while preventing stale approvals and replay attacks.

:::custom-notes[Deep Dive]
For details on how the Operator Service initiates and prepares validator registration, see the [Validator Registration →](../vaults/how-vaults-work#validator-registration) section in Vaults.
:::

## Reward Distribution

Oracles periodically vote on the consensus rewards/penalties accumulated by the Vaults in the Beacon Chain and execution rewards (MEV & priority fees) for the Vaults connected to the Smoothing Pool.

The reward distribution process consists of the following steps:

:::custom-info[Reward Distribution Process]
1. Verify sufficient time has passed since the last reward distribution.
2. Calculate rewards/penalties for all Vaults based on validator balances in the Beacon Chain.
3. Calculate MEV and priority fee rewards for Vaults connected to the Smoothing Pool.
4. Create Merkle trees from the reward calculations and upload them to IPFS. For example, <code>bafkreibqhdr6p5uh67ickt4dpppb525bwuofjocnpsx4dbl57llogfph2e</code>.
5. Save the cryptographically signed vote to the local database and expose via API.
6. The [Keeper service ↗](https://github.com/stakewise/v3-keeper/) fetches votes from Oracle APIs, concatenates them, and sends the resulting transaction to the [Keeper contract ↗](https://etherscan.io/address/0x6B5815467da09DaA7DC83Db21c9239d98Bb487b5#code).
7. Upon verification, the protocol updates global state.
8. Individual Vaults can claim their rewards.
:::

The reward update process has protocol-wide impact.

## Validator Exits

The validator exit process is automated and trustless.
Validator exits require exit signatures that are generated during the [Validator Registration →](../../operator/start-operator) process.

As part of registration, the Operator Service encrypts exit signatures using Shamir's secret sharing and distributes them to all Oracles.

:::custom-notes[Key Benefit]
This approach ensures validators can be exited on demand while maintaining protocol security through decentralized signature management.
:::
